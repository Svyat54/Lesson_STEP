package com.company;
import javax.swing.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class Sorting {
    public static void main (String[] args){
        // Сортировка методом пузырьковой сортировки
//        int sum = 0, a,b,aInd = 0,bInd = 0;
//        int [] arr = new int[] {165,163,160,160,157,157,155,162};

//        boolean isSorted = false;
//        while(!isSorted) {
//            isSorted = true;
//            for (int i = 0; i < arr.length - 1; i++) {
//                if (arr[i] < arr[i + 1]) {
//                    isSorted = false;
//                    a = arr[i];
//                    arr[i] = arr[i + 1];
//                    arr[i + 1] = a;
//                }
//            }
//        }
//        System.out.println(Arrays.toString(arr));



        // Сортировка методом пузырьковой сортировки
//        String text="Исходный массив:\n"; // Текст для окна сообщения:
//        int size,i,j; // Размер массива и индексные переменные:
//        size=Integer.parseInt(JOptionPane.showInputDialog("Размер массива:")); // Получение размера массива:
//        char[] symbs=new char[size]; // Создание символьного массива:
//        char s='a'; // Начальная буква:
//// Заполнение массива (случайным образом):
//        for(i=0;i<size;i++){
//            symbs[i]=(char)(s+(byte)(Math.random()*26));
//            text+=symbs[i]+" ";}
//        text+="\nПосле сортировки:\n";
//// Сортировка массива:
//        for(i=0;i<size;i++){
//            for(j=0;j<size-i-1;j++){
//                if(symbs[j]>symbs[j+1]){
//                    s=symbs[j+1];
//                    symbs[j+1]=symbs[j];
//                    symbs[j]=s;}}
//        }
//// Запись в текстовую переменную элементов массива после сортировки:
//        for(i=0;i<size;i++){
//            text+=symbs[i]+" ";}
//        JOptionPane.showMessageDialog(null,text); // Отображение окна сообщения:

        //Программа работает так: выводится окно с полем ввода, в котором следует
        //указать количество элементов в массиве. Далее введенное пользователем
        //число считывается, и создается одномерный символьный массив symbs
        //с соответствующим количеством элементов. Для заполнения массива вы-
        //полняется оператор цикла, в котором индексная переменная i перебирает
        //все элементы массива, а значение элементам массива присваивается коман-
        //дой symbs[i]=(char)(s+(byte)(Math.random()*26)). Символьная
        //переменная s предварительно, до начала оператора цикла получила значе-
        //ние 'a'. Этот код, пожалуй, требует некоторых пояснений. Так, командой
        //(byte)(Math.random()*26) генерируется случайное целое число в диа-
        //пазоне от 0 до 25 включительно. Полученное значение складывается с сим-
        //вольной переменной s. Благодаря автоматическому приведению типов та-
        //кая операция выполняется на уровне сложения кодов. Чтобы полученный
        //код преобразовать в символ, используем инструкцию явного приведения
        //типов (char). Таким образом, получаем случайным образом сгенерирован-
        //ную букву, чего мы и добивались.
        //Командой text+=symbs[i]+" " значение элемента несортированного
        //массива дописывается в переменную text. После завершения оператора
        //цикла командой text+="\nПосле сортировки:\n" в этот текст добав-
        //ляется заглавная фраза и инструкция перехода к новой строке. Самое время
        //приступить к сортировке массива.
        //Сортировка выполняется по возрастанию значений элементов с помощью двух
        //вложенных операторов цикла. Внешний цикл перебирает "заходы": каждый за-
        //ход – это один полный перебор элементов массива со сравнением и переста-
        //новкой элементов, если необходимо. Внутренний цикл нужен для непосред-
        //ственного перебора элементов. Здесь принято во внимание, что после каждого
        //"захода" перебирать элементов нужно все меньше и меньше: при первом пере-
        //боре сравниваются все элементы массива, при втором переборе сравнивают-
        //ся все элементы, кроме последнего – он и так самый "большой", при третьем
        //переборе нет смысла проверять значения последних двух элементов и так да-
        //лее. Поэтому для индексной переменной внутреннего цикла указано условие
        //j<size-i-1, зависящее от индексной переменной внешнего оператора цикла.
        //Основу процедуры сравнения составляет условный оператор: если элемент
        //слева больше элемента справа, выполняется их перестановка.

        //решение с помошью перебора всех пар чисел
        //функция twoSum которая принимает массив чисел и число "к" и возвращает массив чисел
//        int [] twoSum(int[] nums, int k) {
//            for (int i = 0; i < nums.length; i++){
//                //ещё один цикл с проходом справо от первого и до длины массива
//             for (int j = i + j; j < nums.length; j++){
//                 // смотрим на сумму этих чисел
//                 if (nums[i] + nums[j] == k){
//                     return new int[]{nums[i],nums[j]}; // возвращаем новый массив с элементами i и j
//                 }}}
//            return new int[0];}

        // Hashset
//        int [] twoSum(int[] nums, int k) {
//            Set<Integer> set = new HashSet<>();
//            // с лево на право проверка чисел
//            for (int i = 0; i < nums.length; i++){
//                int numberToFind = k - nums[i];
//                // проверяем встречалось ли нам ранее это число
//                if (set.contains(numberToFind)){
//                    return new int[]{numberToFind, nums[i]};
//                }
//                set.add(nums[i]); //если ретёрн выше не нашел число, записывает новое и повторяет этап снова пока не закончится массив или не найдёт число
//            }
//            return new int[0];}

        //Бинарный поиск
//        int [] twoSum(int[] nums, int k) {
//            for(int i =0; i < nums.length; i++){
//                int numberToFind = k - nums[i];
//                int l = i + 1, r = nums.length-1;
//                while (l<=r){
//                    int mid = l + (r-l)/2;
//                    if (nums[mid] == numberToFind){
//                        return new int[]{nums[i], nums[mid]};
//                    }
//                    if (numberToFind < nums[mid]){
//                        r = mid - 1;
//                    } else {l = mid + 1;}}
//                }
//                return new int[0];
//            }

        // Метод двух указателей
//        int [] twoSum(int[] nums, int k) {
//            int l = 0, r = nums.length - 1;
//            while (l<r){
//                int sum = nums[l] + nums[r];
//                if (sum == k){
//                    return new int[]{nums[l], nums[r]};
//                }
//                if (sum < k){
//                    l++;
//                } else {r--;}
//            }
//        return new int[0];}



    }
}
